import type { App } from "@/lib/app/app";
import { getBlockNode } from "@/lib/app/block-manage";
import { tx } from "@/lib/app/tx";
import type { BlockId, BlockNode, SelectionInfo } from "@/lib/common/types";
import { buildTextContent, toMarkdown } from "@/lib/editor/utils";
import type { LlmModelConfig } from "./useLlm";
import { getEditorFromApp, getLastFocusedEditor } from "@/lib/app/editors";
import { nanoid } from "nanoid";
import { getAbsPos } from "@/lib/editor/editor";
import { outlinerSchema } from "@/lib/editor/schema";
import LLM, { type LLMServices, type PartialStreamResponse } from "@/lib/llm";
import type { Emitter } from "mitt";
import mitt from "mitt";
import { TextSelection } from "prosemirror-state";
import { Fragment, Slice } from "prosemirror-model";
import { prompts } from "./prompt";

export type LlmAppendChildrenTaskEvents = {
  "update:status": LlmAppendChildrenTask["status"];
};

export type LlmAppendChildrenTask = {
  ctxBlockId: BlockId;
  config: LlmModelConfig;
  lastInsertPos: SelectionInfo | null;
  llm: LLMServices | null;
  rspChunks: any[];
  status: "created" | "generating" | "success" | "aborted" | "failed";
  eb: Emitter<LlmAppendChildrenTaskEvents>;
};

function create(app: App, ctxBlockId: BlockId, config: LlmModelConfig) {
  const task: LlmAppendChildrenTask = {
    ctxBlockId,
    config,
    lastInsertPos: null,
    llm: null,
    rspChunks: [],
    status: "created",
    eb: mitt(),
  };
  return task;
}

/**
 * LlmAppendChildrenTask 执行前的准备工作
 *
 * 比如：
 * - ctxBlockNode
 *   - xxx
 *   - yyy
 *   - 2025-07-04 10:00:00 generated by gpt-4o <-- llmRootNode
 *     - <-- llmContentNode, empty block for ai content
 */
function prepare(app: App, task: LlmAppendChildrenTask) {
  return tx(
    app,
    (txObj) => {
      const ctxBlockNode = getBlockNode(app, task.ctxBlockId);
      if (!ctxBlockNode) return;

      const timestamp = new Date().toLocaleString("sv-SE");
      const llmRootNode = txObj.insertBlockUnder(
        ctxBlockNode,
        (data) => {
          const { type, content } = buildTextContent(
            `${timestamp} generated by ${task.config.model}`
          );
          data.set("type", type);
          data.set("folded", false);
          data.set("content", content);
        },
        ctxBlockNode.children.length
      );

      const llmContentNode = txObj.insertBlockUnder(llmRootNode, (data) => {
        const { type, content } = buildTextContent("");
        data.set("type", type);
        data.set("folded", false);
        data.set("content", content);
      });

      const editorId = getLastFocusedEditor(app)?.id;
      const initInsertPos = {
        editorId,
        blockId: llmContentNode.id,
        anchor: 0,
      };
      task.lastInsertPos = initInsertPos;

      txObj.updateOrigin({ selection: task.lastInsertPos });
    },
    {
      type: "localEditorStructural",
      txId: nanoid(),
    }
  );
}

function updateStatus(
  task: LlmAppendChildrenTask,
  status: LlmAppendChildrenTask["status"]
) {
  task.status = status;
  task.eb.emit("update:status", status);
}

function start(app: App, task: LlmAppendChildrenTask) {
  try {
    queueMicrotask(async () => {
      await prepare(app, task);

      // 等待 textContent 更新
      // await new Promise((resolve) => setTimeout(resolve, 1000));

      const { config, ctxBlockId } = task;
      const userPrompt = toMarkdown(app, [ctxBlockId]);
      const llm = new LLM(userPrompt, config);
      task.llm = llm;

      updateStatus(task, "generating");
      llm.assistant(prompts.formatPrompt);
      const _rsp = await llm.chat(userPrompt, { stream: true });
      const rsp = _rsp as PartialStreamResponse;

      for await (const _chunk of rsp.stream) {
        const chunk = _chunk as any;
        task.rspChunks.push(chunk);
        console.log(chunk);
        if (chunk.type === "content") {
          insertLlmContent(app, task, chunk.content);
        }
      }

      updateStatus(task, "success");
    });
  } catch (err) {
    console.error(err);
    updateStatus(task, "failed");
  }
}

function abort(task: LlmAppendChildrenTask) {
  if (!task.llm) throw new Error("llm is null");
  task.llm.abort();
  updateStatus(task, "aborted");
}

function insertLlmContent(
  app: App,
  task: LlmAppendChildrenTask,
  newContent: string
) {
  if (!task.lastInsertPos) throw new Error("lastInsertPos is null");
  const { editorId, blockId, anchor } = task.lastInsertPos;

  const editor = getEditorFromApp(app, editorId);
  if (!editor.view) throw new Error("editor.view is null");

  const doc = editor.view.state.doc;
  const absPos = getAbsPos(doc, blockId, anchor);
  if (absPos === null) throw new Error("failed to calculate absPos");

  const tr = editor.view.state.tr;
  const frag = Fragment.from([outlinerSchema.text(newContent)]);
  const slice = new Slice(frag, 0, 0);
  tr.replaceSelection(slice);
  const insertPos = tr.selection.to;
  const newSelection = TextSelection.create(tr.doc, insertPos);
  tr.setSelection(newSelection);
  editor.view.dispatch(tr);
}

export const AppendChildrenTaskUtils = {
  create,
  prepare,
  start,
  abort,
  insertLlmContent,
};
